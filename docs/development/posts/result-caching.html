<!DOCTYPE html><html><head><title>Result Caching &ndash; Lynx</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="stylesheet" href="/styles.0424bf09.css"><link rel="icon shortcut" type="image/png" href="/favicon.f1cf22ff.png"></head><body> <div id="header"> <a href="/"> <div id="logo" class="header-tab"> <img src="/lynx_logo.04401f14.svg" alt="home" height="80" width="80"> <div style="padding-top:38px;font-weight:500;font-size:30pt;align-items:baseline;">Lynx</div> </div> </a> <a class="header-tab" href="/demos/">Demos</a> <a class="header-tab" href="/development/">Development</a> <a class="header-tab" href="/whitepaper/">Whitepaper</a> </div> <div class="content"> <h1 class="blogTitle">Result Caching</h1> <div class="blog-metadata">12 December 2020 <i>&#8212; Bryan Mehall</i></div> <p> One of the reasons for the last re-write of lynx was the speed of recursive functions. When an attribute of an object was accessed more than one time in the same scope it's value was recomputed with each access instead of being stored. With recursive functions this leads to exponential time complexity whenever an attribute is evaluated more then once. </p> <p> The intended fix is to ensure that the lynx expression keeps the evaluated results of attributes whenever a primitive is being evaluated. This way the value does not need to be re-computed. A problem with this approach is the complexity of invalidating the cache whenever a cached value changes. This is handled by the modules system that will be explained elsewhere. </p> <p> The first solution for caching used the </p> <div class="blog-metadata footer"> previous: <a href="/development/posts/initial-commit.html">Initial Commit</a> next: <a href="/development/posts/argument-storage.html">Argument Storage</a> </div> </div> </body></html>