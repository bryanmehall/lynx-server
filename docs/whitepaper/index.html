<!DOCTYPE html><html><head><title>Whitepaper &ndash; Lynx</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="stylesheet" href="/styles.96bfff2f.css"><link rel="icon shortcut" type="image/png" href="/favicon.f1cf22ff.png"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></head><body> <script>window.MathJax={loader:{load:["ui/lazy"]},chtml:{scale:.8},svg:{scale:.8},tex:{macros:{link:["\\class{def}{\\href{#1}{#2}}",2]}}},window.onload=(()=>{document.querySelectorAll(".def").forEach(e=>{e.addEventListener("click",e=>{e.preventDefault();const t=document.getElementById("notes"),n=e.target,l=n.getBoundingClientRect().top-t.getBoundingClientRect().top,d=`${n.href.substring(n.href.lastIndexOf("#")+1)}-aside`,o=document.getElementById(d).cloneNode(!0);null===o?console.warn(`no aside with id "${d}" found`):(o.style.top=`${l}px`,o.style.display="block",o.classList.add("notes"),t.appendChild(o))})})});</script> <div id="header"> <a href="/"> <div id="logo" class="header-tab"> <img src="/lynx_logo.04401f14.svg" alt="home" height="80" width="80"> <div style="padding-top:38px;font-weight:500;font-size:30pt;align-items:baseline;">Lynx</div> </div> </a> <a class="header-tab" href="/demos/">Demos</a> <a class="header-tab" href="/sandbox/">Sandbox</a> <a class="header-tab" href="/development/">Development</a> <a class="header-tab" href="/whitepaper/">Whitepaper</a> </div> <div class="content"> This is a working draft of the design rationale and formal specification of the Lynx Programming Language </div> <div class="whitepaper"> <div class="outline"> <ul> <li><a href="#design">Part I &#8211; Design</a></li> <ul> <li><a href="#what-is-programming">What is Programming?</a></li> <li>Programming Interface</li> <ul> <li>Human Representations</li> <li>Why Not Code?</li> <li>Machine Representations</li> </ul> <li>Programming Ecosystem</li> <ul> <li>The Mess We're In</li> </ul> <li>Software Correctness</li> </ul> <li><a href="#specification">Part II &#8211; Specification</a></li> <ul> <li><a href="#object-context">The Object-Context Paradigm</a></li> <li><a href="#type-hierarchy">Type Hierarchy</a></li> <li><a href="#statics">Statics</a></li> <ul> <li>Abstract Syntax</li> <li>Typing Judgements</li> </ul> <li>Dynamics</li> <li><a href="#types">Types</a></li> <ul> <li>Equality</li> <li>Subtyping</li> <li>Canonicity</li> <li>Approximations</li> </ul> <li>State</li> <li>Events</li> </ul> <li><a href="#implementation">Part III &#8211; Implementation</a></li> <ul> <li>Metacircularity</li> <li><a href="#persistence">Persistance</a></li> <li><a href="#primitives">Primitives</a></li> <li>Modules</li> <li>Compilation</li> <li>Parallelism</li> <li>Errors</li> <li>Optimization</li> <li>Approximation</li> </ul> </ul> </div> <div class="formal whitepaperContent"> <h1 id="design">Part I &#8211; Design</h1> <p> Lynx is a computable specification language designed to make building great software more intuitive and efficient. Programming is fundamentally about human communication. After a brief discussion about the philosophy behind Lynx and what a programming ecosystem should look like, this document will detail the formal specification of the Lynx language. </p> <div> <h2 id="#what-is-programming">What is Programming?</h2> <p> When most people think about programming they think about writing code. Instead, it should be thought of in a more abstract way as the act of communicating complex ideas precisely. With traditional programming languages, programmers are really doing two separate acts at the same time: Writing code to communicate with computers and writing documentation to communicate with other programmers. These two parts are held together with an informal set of best practices that are but they should be unified within a programming environment. </p> <embed src="/design-spec-implementation.drawio.8c608d6a.svg" type="image/svg+xml" class="diagram"> </div> <div> <h2 id="programming-interface">Programming Interface</h2> <h3 id="why-not-code">Why not code? </h3> <p> Traditional text-based coding is the standard that almost every general purpose programming language uses because of its expressive power and flexibility. It provides a consistent interface for every program and the text that is visible is the entirety of the implementation. The few graphical programming languages that exist fall short because they try to replicate the semantics of text-based code but in graphical form. Lynx takes a different approach. </p> <p> why graphical is good-- </p> <p> Functional programming focuses on a single type of relations between objects: How an object is evaluated. While this is is an interesting property of an object, and probably the most useful from a computational perspective, it makes programming in a functional style difficult. The solution is to add a generalization of relations between objects where the concept of evaluation is only one of them. </p> <p> Lynx offers features for determining how the result of a program was defined built into the language. Say a programmer is implementing a collision detection algorithm but it isn't working properly...introspect into how the collision boolean was defined instead fo stepping forward through imperative code to the point of the error When combined with graphical representations of each of these concepts this forms an extremely powerful debugging tool </p> <p> Keep track of definitions. In most languages, computation is uni-directional. Lynx keeps track of where values come from so that it can be audited at a later time. This feature creates an extremely powerful tool for debugging programs. Instead of a programmer needing to understand the whole structure of a program and work forward to a bug, theycan see where there is an incorrect value and then work backwards. </p> <p> Sum types --good for checking where a program must be updated </p> </div> <p> The correctness of lynx programs is defined by a single guiding principle: <i>All information justifying the correctness of a program should be part of the program.</i> This includes documentation, implied information in the code and detailed information about the compiler. </p>When designing a line intersection algorithm, the programmers should be able to see the lines and not have it hidden. if zipping two lists then there should be some justification that they are the same length and this justification should be part of the program When using floating point numbers, the programmer should know specify that the final result will be within certain error bounds. <h1 id="specification">Part II &#8211; Specification</h1> <div> <h2 id="object-context">The Object-Context Paradigm</h2> <p> With lynx we introduce a new programming paradigm called the object-context paradigm. The object oriented style matches the way people think about concepts in the real world more closely than functional or imperative programming styles. This is one reason for the relative popularity of object oriented programming. Lynx uses a carefully constrained form of Object Oriented programming so that programs have a more intuitive understanding while still allowing for the more strict program analysis like in a functional paradigm. Lynx can also be thought of as a purely declarative form of object oriented programming. </p> <p> Objects in Lynx consist of a mapping between attributes and values. Both attributes and values are also objects. One way to represent objects graphically is with a tree diagram where the objects are nodes and the attributes are edges. </p> <object type="image/svg+xml" data="/object-value.drawio.93711e25.svg" class="diagram"></object> <p> Objects can have multiple attributes that are represented as different branches of the tree. and because values are also objects the tree can be multiple levels deep. This forms a recursive data type that can be used to represent any other data type in lynx. </p> <object type="image/svg+xml" data="/multiple-attributes.drawio.24a43669.svg" alt="Objects can have multiple attributes" class="diagram"></object> <p> We will use text being drawn on a screen as an example. The text can have several attributes like its position on the screen, the string to be printed, font type, font size etc. We can also attach metadata like the name of the textbox as an attribute. </p> <object type="image/svg+xml" data="/simple-text-box.drawio.863e0985.svg" alt="Objects can have multiple attributes" class="diagram"></object> <p> Every tree or subtree in this diagram is an object. So far, this is just describes a static graphical layout. Lynx is able to do computation when we introduce context and references. </p> <p> We can describe a text object (text box) whose position is defined by the graphical element it is put inside. We will call the "parentElement" of the text box "group" and then we will put the group element inside of a window. </p> <object type="image/svg+xml" data="/text-box.drawio.32b88de9.svg" alt="Objects can have multiple attributes" class="diagram"></object> <p> This can be represented by the lynx object tree: </p> <object type="image/svg+xml" data="/text-box-tree.drawio.5c13955c.svg" alt="Objects can have multiple attributes" class="diagram"></object> <p> In this case the text object (text and everything below it) is placed in the context of the group. The text object has two references that refer to values outside of the text object. The reference "group.position.x" refers to the the x component of the position of the group object. The text object will always behave the same way if it is placed in an identical "group" context. We can think of an object as a pure function and the references to the context it is in corresponds to the arguments of that pure function. So now if we change the position of the "group" element then the text will follow and always be offset by \((20, 20)\) </p> <object type="image/svg+xml" data="/text-box-moved.drawio.50d67ff6.svg" alt="Objects can have multiple attributes" class="diagram"></object> <p> We've now made these definitions dynamic but with this system "text" is not really isolated from "group" because the references still refer to "group" by name. It would be nicer if we could say that the position of "text" is relative to whatever it's parent element is. To solve this problem we can define a concept called an inverse attribute. In this case "parentElement" is the inverse attribute of "childElement" </p> <object type="image/svg+xml" data="/inverse-attributes.drawio.9ea183ae.svg" alt="Objects can have multiple attributes" class="diagram"></object> <p> With inverse attributes, the definition of "text" depends on the context it is in. Its parentElement can have any name but it must have a position with x and y attributes. We can again think of text as a pure function with these references as arguments. </p> <p> This forms the core part of the lynx language. Next, we will look at how these object graphs can change over time in response to new data and store state. </p> <h3>Events and State</h3> <p> So far, we have discussed how static lynx objects are structured and evaluated. They can also change in response to outside events and store data. We'll start with a simple, non-stateful example where the position of the text box is set to be the position of the user's mouse. </p> <object type="image/svg+xml" data="/mouse-move.drawio.bdedc310.svg" alt="Objects can have multiple attributes" class="diagram"></object> </div> <div> <h2 id="type-hierarchy">Type Hierarchy</h2> Lynx should be thought of more as a specification language than a programming language because it is designed with an extra layer of abstraction that makes it possible to manipulate meta-data about programs. In Lynx, any concept is considered to be a subtype of something called a Lynx Object. The type hierarchy is a partial order on the "is A" relationship on objects. This generally behaves in the same way as types in traditional languages. For example, 3 is A number that will be written with the notation 3:Number. For practical purposes in the subtyping partial order, Lynx Object is the single the greatest element. This is not strictly true because there is some machinery to avoid paradoxes so some of the details are suppressed here for clarity. Instances of objects will be referred to as \(Atoms\) are the least elements of the type hierarchy. Other than their name, there is no distinction between instances and types in Lynx. For example, the number "3" is just a subtype of the type "number". Most languages have the distinction between types and values to draw a line between concepts that can be checked at compile time and then thrown away. This means that when using dependent types if we want to use the type Natural numbers to measure the length of the array then we would ordinarily need a natural number type for use at runtime and a natural number kind to use at compile time. Lynx instead allows for there to be no distinction between compile time and run time but forces expression evaluation to be typed to make sure that the correct information is being discharged at run time. <object type="image/svg+xml" data="/type-hierarchy.drawio.dc357000.svg" alt="type hierarchy" class="diagram"></object> We can divide the type hierarchy into 4 general sections: <ol> <li> <b>Lynx Objects:</b> a kind of way of storing meta-data and relations between objects. In the type system, everything is a subtype of Lynx Object </li> <li> <b>Abstract Types:</b> types like product types, sum types and function types are defined in terms of lynx expressions and are therefore a subtype of lynx objects. </li> <li> <b>Concrete Types:</b> numbers, strings lists, trees, etc. are subtypes of abstract types </li> <li> <b>Instances:</b> 1,2,3, "abc" are all subtypes of their corresponding types. </li> </ol> <p> For each of these sections of the type hierarchy we will create a specification for each object in two steps: <ol> <li><b>statics: </b>specification of what makes a program well-formed</li> <li><b>dynamics: </b>specification for evaluating a well-formed program</li> </ol> Unlike most languages, Lynx does not have separate phases for write-time, type checking, compile-time and run-time. Therefore the dynamics are defined in such a way that at every step of evaluation the resulting program is also correct as defined by the statics. More formally, given a well-formed Lynx expression \(e\) and a computational event \(\mapsto\) the dynamics ensures that that the resulting Lynx expression \(e'\) is also well-formed for the evaluation expression \(e \mapsto e'\) </p> </div> <div> <h2>Lynx Objects</h2> <h3 id="statics">Statics</h3> <h5 id="lynx-expression">Lynx Objects \((\mathcal{O})\)</h5> \[LynxObject ::= \left\{ a \: |\: a:( \link{#lynx-attribute}{Attribute}, LynxObject) \right\}\] <embed src="/lynx-object.drawio.ebf19831.svg" alt="Structure of a Lynx Object" class="diagram"> <aside id="lynx-object-aside" style="display:none;"> <span class="def">Lynx Objects</span> consist of a set of mappings between attributes and values </aside> <a href="#lynx-object" class="def">Lynx Objects </a> consist of a set of mappings between an <a href="#lynx-attribute" class="def">attribute</a> and another Lynx Object. The definition is intentionally broad because they are designed to encapsulate the properties, metadata, and relations of any concept. They are the only first-class concepts in the lynx language. Note that Lynx objects don't inherently contain any information. Their meaning is only derived by their relation to other objects. To highlight why this design decision is important, we can use the concept of a function as an example. Something like a function that would normally be a first class object in a programming language is not in lynx because it would be missing important meta-data. Lynx objects can capture the essential information about functions by defining an "argument" and a "result" attribute that can be used by the evaluator. The name of the function other meta-data can also be added as an attribute. The inverse of the function can be added as a relation. The structure of Lynx Objects form a graph where the objects are nodes and the attributes are edges. <h5 id="lynx-attribute">Attributes</h5> \[Attribute ::= \left\{ a \: |\: a:(Attribute, \link{#lynx-object}{LynxObject}) \right\}, \link{#lynx-property}{Property} \:|\: \link{#relation}{Relation}\] Attributes are a subtype of Lynx Objects. In most of the lynx object graphs shown attributes are just edges for clarity but attributes can have their own attributes just like any lynx object. These attributes of attributes can imply more structure like that the inverse of <h5 id="lynx-expression">Lynx Expression \((e)\)</h5> <aside id="lynx-expression-aside" style="display:none;"> <span class="def">Lynx Expressions</span> are like Lynx Objects but limited to a tree structure. They consist of a finite set of (property, LynxExpression) pairs. The tree structure is useful for the analysis and storage of parts of Lynx Objects. A Lynx Expression placed in a context \((\Gamma) \) forms a Lynx Object. </aside> \[LynxExpression ::= \left\{ a \: |\: a:(\link{#lynx-property}{Property}, LynxExpression \: | \: Atom \: | \: Reference) \right\}\] Lynx Expressions are an inductively defined tree structure consisting of a mapping between a finite set of <a href="#lynx-property" class="def">Properties</a> and corresponding <a href="#lynx-expression" class="def">Lynx Expressions</a>. Lynx Expressions are useful for the serialization, analysis and storage of <a href="#lynx-object" class="def">Lynx Objects</a>. Lynx expression can always be serialized and content addressed because they are non-cyclic by definition. This is covered in more detail in the Object Persistance specification. Lynx Objects can be simplified to Lynx Expressions with respect to certain properties. For the remainder of the whitepaper Lynx Expressions will be denoted with the letter \(e\) with subscripts \(e_1, e_2 \) etc. to differentiate between unequal expressions. <h5>Lynx Value \((v)\)</h5> \[LynxValue ::= \left\{ a \: |\: a:(\link{#lynx-property}{Property}, LynxValue \: | \: Atom) \right\}\] A Lynx Value is a subtype of a Lynx Expression where every property is also a Lynx Value. Lynx values are often used as the base case for evaluation rules. <h5>Context \(\left(\Gamma\right)\)</h5> \[Context (\Gamma) ::= \{a \:|\: a:(Attribute, LynxObject)\}\] such that \[Context \cup LynxExpression = Lynx Object\] More informally, a Lynx Expression placed into a context forms a Lynx Object. The behavior of the expression is a pure function of the context it is placed in. The set of references within a Lynx Epression that depend on the context will be called arguments, and are discussed in more detail in the implementation section. <h5 id="lynx-property">Properties</h5> \[Property ::= \link{#lynx-expression}{LynxExpression}\] A lynx property is a non-cyclic version of an attribute. It can not have relations to other properties or attributes. <h5 id="relation">Relations</h5> \[Relation ::= \link{#lynx-object}{Lynx Object}\] <h5 id="reference">Relative References</h5> \[RelativeReference ::= \left\{(rootObject, Root), (attribute, \link{#attribute}{Attribute}) \right\}\] where \[Root = \link{#lynx-object}{LynxObject} \:| \: RelativeReference \: | \: \link{#local-reference}{LocalReference} \: | \: \link{global-reference}{GlobalReference}\] \(rootObject:Attribute\) and \(attribute:Attribute\) Relative references are just lynx expression with two essential attributes. The \(rootObject\) attribute refers to the object to get \(attribute\) with respect to. For example, if we want to get the \(length\) attribute of a string then string would be the rootObject, length would be the attribute and the reference would have the text notation <span class="code">string.length</span> \[\frac{\Gamma \vdash Root:\tau_1 \quad \tt{Attribute}:\tau_1\rightarrow \tau_2}{\class{code}{Root.Attribute}:\tau_2}\] <h5 id="local-reference">Local References</h5> \[LocalReference ::= (Query, String)\] <h5 id="global-reference">Global References</h5> \[GlobalReference ::= (Query, String)\] <h5>Events \((\mapsto)\)</h5> <h4>Context Splitting</h4> Lynx Objects are the composition of a Lynx Expression and some context, but to be able to store and analyze Lynx Expressions there also must be a process for decomposing a Lynx Object into a Lynx Expression and a context. Lynx Objects are a possibly infinite set of \((\link{#lynx-object}{LynxObject}, \link{#attribute}{Attribute})\) pairs. <ul> <li>parameterize attributes</li> <li>split attributes so properties are part of the expression and non essential relations are in the context </li> </ul> <h3 id="dynamics">Dynamics</h3> Objects in Lynx are connected by attributes, but to be able to do computation we need to add a few concepts. The big idea is that the program we are running and the result we are trying to arrive at already exist in the interconnected graph of objects and we only need to move from the definition to the result. We will present two equivalent ways of specifying the evaluation of lynx programs. Structural Dynamics vs Evaluation Dynamics The structural dynamics detail the individual evaluation steps. We have not specified the lynx event system yet but each evaluation step is a computation event. <h4>Structural Dynamics</h4> The structural dynamics for <a href="#lynx-expression" class="def">Lynx Expressions</a> are defined in terms of computation events of the form \(e_1 \mapsto_\tau e_2\) where \(e_1\) is the initial expression, \(\mapsto\) is the computation event, \(\tau\) is the type in which \(e_1\) is being evaluated in, and \(e_2\) is the resulting expression. For this section we will only be concerned with evaluating <a href="#lynx-expression" class="def">Lynx Expressions</a> in the type <a href="#lynx-expression" class="def">Lynx Expression</a>. Computation events can be grouped together sequentially to form more complex computation events: \(e_1 \mapsto e_2 =_\mapsto e_1 \mapsto e_{1a} \mapsto e_{1b} \mapsto e_2\). Multiple computation events in sequence is denoted by \(\mapsto^*\). <h4>Safety</h4> To ensure that the program will not encounter any illegal state at runtime, We introduce the concept of safety with two principles: Preservation and progress. <div class="thm">Preservation</div> If a we have a lynx expression \(e_1:\tau\) and we want to evaluate \(e_1\) in type \(\tau\) to form another expression \(e_2\) \((e_1 \mapsto_\tau e_2)\) then we want to ensure that \(e_2:\tau\) <div class="thm">Progress</div> If \(e_1:\tau\) then either \(e_1\) is a value in type \(\tau\) or \((e_1 \mapsto_\tau e_2)\). Together, these principles ensure that the program can never enter an illegal state. <div class="thm">Coherence</div> We want to ensure that evaluating a given expression at the <a href="#lynx-expression" class="def">Lynx Expression</a> level will have the same type as evaluating it in a subtype. <div class="thm">Canonicity</div> Discussed in more detail in the Canonicity section. -cost of events -isomorphism to result attribute -keep track of definitions <h4>Attribute Application</h4> Now we will define a computational event called \(\text{apply}\) that transitions from one <a href="#lynx-expression" class="def">Lynx Expression</a> to another with respect to a certain attribute. If we have an expression \(e_1\) then we can use \(\text{apply}\) to create another expression \(e_2\) where \(e_2 = \text{apply}(e_1, \text{attribute})\) The expression \(e_2\) contains some extra information including <span class="def inverseattribute">inverseAttributes</span> and <span class="def parentvalue">parentValue</span>. This transition is shown with the following Lynx Expression graph. <object type="image/svg+xml" data="/apply.drawio.e5379640.svg" alt="Evaluation of local reference node" class="diagram"></object> <p> The red arrow is for a special attribute called <span class="def parentvalue">parentValue</span>. These parentValue attributes effectively keep track of which way is "up" in the object graph. This is used for determining which named references (called localSearch in the code base) are within scope. In the text example "text" and "graph" were in scope for the references because there were implicit parentValue attributes that led from the reference to the text and graph objects. ParentValue doesn't affect the behavior of apply and will be discussed more formally in the evaluation semantics for references. </p> <p> The \(\text{apply}\) computational event has a few important properties: reversibility, attribute selection, and composability </p> <div class="thm">Reversibility</div> <p> Every evaluation step is reversible. If we have an expression \(e_2\) defined as \(e_2 =_\mathcal{O} \text{apply}(e_1, \text{attribute})\) and an attribute that is inverse to \(\text{attribute}\) called \(\text{inverseAttribute}\) then we can say \(e_1 =_\mathcal{O} \text{apply}(e_2, \text{inverseAttribute})\) </p> <object type="image/svg+xml" data="/apply-reversibility.drawio.ead7b5e1.svg" alt="Evaluation of local reference node" class="diagram"></object> Notice that the structure of \(e_1\) is not the same as it was originally but its computational behavior will be the same. If we apply \(\text{attribute}\) to \(e_1\) again, it will have an identical structure as \(e_2\). To maintain this property, parentValue attributes are always added pointing toward original position of the cursor before any evaluation steps are taken and are not added when following an inverse attribute. We keep track of this orientation by defining an attribute as inverse when it is pointing up. This way if we are evaluating an inverse attribute we know the cursor is moving up the tree and if we are evaluating a normal attribute then the cursor is moving down the tree. Not every attribute has an inverse so we add an implied inverse attribute called "parentValue" to every evaluation step where we are moving down the tree. We don't add it when an evaluation step moves up the tree to keep the reversibility requirement. <div class="thm">Attribute Selection</div> In the examples so far the object only has one attribute. If we have an object with two attributes called attribute1 and attribute2 then the evaluation function can select which attribute it follows. In the diagram below it evaluates attribute1 but it could also evaluate attribute2. In the general case it can evaluate any attribute of the cursor object. <object type="image/svg+xml" data="/apply-selection.drawio.6d39e459.svg" alt="Evaluation of local reference node" class="diagram"></object> <div class="thm">Composability</div> <object type="image/svg+xml" data="/apply-compose.drawio.ddf8cc4a.svg" alt="Evaluation of local reference node" class="diagram"></object> <h4>Reference Evaluation</h4> <p> To evaluate references let there be a computational event \(\text{evaluate}\) that transitions a Lynx Expression with the cursor on a reference node to another lynx expression. The "evaluate" computational event is a subtype of the "apply" computational event where the attribute parameter of apply is subclassed with the "result" attribute. The result attribute indicates simplification of an expression and has in inverse called "definition". </p> <p> Before we can define \(\text{evaluate}\) we need to go into more detail on the structure of reference objects. (in the code base they are sometimes called "get objects") The concise text representation of a reference that we saw before is "text.position" where we are searching for the object "text" by name and then referring to its "position" attribute. These references can be chained so "text.position.x" refers to the x-component of the position of the text. To generalize, the reference "object.attribute" is the text representation for a reference where "object" is the object to be searched for by name and "attribute" is the attribute to follow from object. Objects can be searched for by name within their context. </p> <p> References are just Lynx objects. They have an attribute "rootObject" and an attribute "attribute". LocalSearch objects have an attribute "query" that is matched against objects in its scope. The object diagram for the reference "object.attribute" looks like this: </p> <object type="image/svg+xml" data="/local-reference-eval.drawio.59cc68e7.svg" alt="Evaluation of local reference node" class="diagram"></object> <object type="image/svg+xml" data="/relative-reference-evaluation.drawio.955ee4b4.svg" class="diagram"></object> <h4>Evaluation Dynamics</h4> </div> <div> <h2>Abstract Types</h2> In most languages, abstract types like sum types, product types and function types are first class concepts but in lynx they are subtypes of Lynx expressions. The meaning of the abstract types is given by their behavior upon evaluation. We will start with the simplest abstract types and then work towards the most general abstract types. A brief note on notation. \(a:A\) means a is a subtype of A. <h3 id="atom">Atoms</h3> \[Atom_\tau ::= \{...\} \:| \:\{a \:|\: a:(Attribute^*_\tau, Atom_\tau), ...\}\] Atoms (sometimes called unit types in other languages) are the building blocks of all abstract types in Lynx. They can be considered objects with no additional information. Any single concept you can think of is an atom. For example, the number zero is an atom. So is the number "3" , the letter "a" or the boolean "true". More complicated data structures like the entire friend connection graph on a social network at any given instant are also an atom. Any concept where there is exactly one of that type can be considered an atom with respect to its own type. In Lynx, Atoms are just objects with no essential information. They can have meta-information and relations to other objects but this information can not change the meaning of the atom. We can form the following typing judgements for atoms: <div class="thm">Atomic Reflexivity</div> \[\frac{a: Atom_\tau}{a =_\tau a}\] What does it mean for it to be an atom in type tau? Do we want to say \(a:Atom \quad a:\tau\) or do we want to say that an object can be an atom in one type but not in another? ie. \(Nat = Zero | One | Two |Three...\) this would correctly make the statement \(Three:successor(Nat)\) We can say that any two atoms of the same type that are definitionally equal to each other are equal to each other in the same type. This pattern is essential for reducing global complexity of code and its power will be more apparent when we introduce more complex types. If we have two developers working on the same concept without the knowledge of the other, this offers a mechanism to essentially merge the two concepts into one and ensure the correctness of all dependent code. We will start with a simple case of this for atoms and add more complex cases with more complex types. <div class="thm">Atomic Equality</div> \[\frac{a:Atom_\tau \quad b:Atom_\tau \quad a\equiv_\tau b}{a =_\tau b}\] An atom is an empty Lynx Object with no properties. Atoms form the leaves of Lynx Object trees. For example, The number is zero is an atom in the type of natural numbers. How do lynx objects handle atoms and what do they look like? How do we formalize the transformation of a lynx expression into a lynx object? <h3>Binary Sum Types</h3> \[BinarySum ::= \{(element_1, a:\link{lynx-expression}{LynxExpression}),(element_2, b:\link{lynx-expression}{LynxExpression}), ...\}\] While any concept in lynx can be represented as an Atom, programs constructed only from atoms would lack any structure. Let's first look at an example of a sum type of atoms. If we have two atoms called \(True\) and \(False\) then we can define a type called \(Boolean\) defined as \(Boolean = True \:|\: False\). If instances of the type \(Atom\) are defined as having exactly one possible value then the binary sum of two atoms has \(1+1 = 2\) inhabitants. This is where the name sum type comes from. Are Sum types defined as pattern matching on attributes? (we can say \(zero : nat\) and successor(nat) : nat. nat = sumtype(zero, succ(nat)) zero:nat, one:nat one:succ(zero) these don't need to be minimal but they do need to be consistent...What is the implementation of this and of the function search? Sum types are expressed in terms of the isA relation. We will use the natural numbers as an example. We can say that \(zero\) isA naturalNumber and we can say that for any natural number \(n\), \(n\).successor is a natural number. As alluded to in the design section, Lynx has a mechanism for programers to generalize concepts over time and simplify the program <object type="image/svg+xml" data="/least-judgements.drawio.0020724e.svg" class="diagram"></object> <div class="thm">Tagged Union Redundant Element Elimination </div> If the intersection of \(e_1\) and \(e_2\) is non-empty then <div class="thm">Tagged Union Redundant Element Coherence </div> If a type \(\tau\) is defined as a tagged union of two other elements \(e_1\) and \(e_2\) then for every element \(a \in e_1\) and \(b \in e_2\) in the intersection of \(e_1\) and \(e_2\), \(a=_\tau b\) <h3>Binary Product Types</h3> \[BinaryProduct ::= \{(element_1, a:\link{lynx-expression}{LynxExpression}),(element_2, b:\link{lynx-expression} {LynxExpression}), ...\}\] Binary Product types are defined with essential attributes on lynx objects so the product type \[\frac{a:LynxExpression \quad b:LynxExpression}{a \times b : }\] Product types can be subtyped to be atoms with the rule: \[\frac{a:Atom \quad b:Atom}{a\times b:Atom}\] This intuitively makes sense because an atom has one possible value so the product of two atoms is \(1\times1 = 1\) so it also has one possible value. <h3>Function Types \((\rightarrow)\)</h3> there should be a way to search for attributes. If we have an object \(a:A\) then for any function \(f:A \rightarrow B\) there should be an attribute-value pair \((f,b)\) on any Lynx Object of type \(A\) where \(b:B\) <h4>Isomorphism with attribute type</h4> <h4>Partial function interpretation </h4> Partial functions are denoted with the \(\rightharpoonup \) symbol. <h3>Dependent Product Types \((\Pi)\)</h3> \[\prod_{x:A} B(x)\] Dependent product types are a generalization of functions and Product types As a generalization of product types: If we want to make the product type handle more than two inputs then we can rename the types in \(A \times B \times C...\) to \(\tau_0 \times \tau_1 \times \tau_2... \times \tau_i\) and restrict I to be a range of natural numbers \([0, i] = \{0, 1, 2, ...i\}\) then \[\tau_1 \times \tau_2... \times \tau_i =_\Pi \prod_{[0, i]} \tau_i\] <h4>attribute interpretation</h4> <h3>Dependent Sum Types \((\Sigma)\)</h3> \[\sum_{x:A} B(x)\] <h3>Subset Types</h3> For example, if we have <h3>Quotient Types</h3> <h2 id="types">Types</h2> <p> Types are used to constrain the behavior of programs and, when they are well-formed, ensure correctness within the boundaries of the type system. In some dynamically typed languages like javascript or python the typing is considered "weak" because there are very few rules about which objects can be used in which places. This is often seen as a feature because it is less confusing for beginners writing simple programs. </p> <p> Lynx takes the opposite approach. Type structures can always be relaxed selectively but when there is no type structure then the ability to reason about programs is lost. One way of thinking about it is that a weakly typed language can be created in a strongly typed language by purposefully relaxing all of the rules but the rules but a strongly typed language can not be replicated in a weakly typed language so the strongly typed language must be more expressive. </p> <p> <ul> <li>Problem #1: Types specify structure not behavior</li> <li>Problem #2: Equal types are not necessarily interchangeable</li> <li>Problem #3: Data can only be an instance of a single type</li> </ul> </p> <h3 id="types-through-examples">Types Through Examples</h3> <p> When we are programming is is useful to start defining types as the simple case and then creating a more general version later. This process of generalizations often gets programmers in trouble where they used a specific version of a type somewhere in their code and the new generalization breaks it. let's start with a very basic example. We can create a new object called "zero" and say it is an element of the natural numbers by adding a subtype (isA) relation between it and the "natural number" object. </p> <img src="/zero-nat.490f17c2.svg" alt="Zero is a Natural Number" class="diagram" style="width:191px"> <p> Now we can say "one is also a natural number" so we add the definition \(\text{One}: \text{Nat}\) and \(\text{Two}:\text{Nat}\) </p> <img src="/n-nat.a1d83c7d.svg" alt="Zero is a Natural Number" class="diagram" style="width:221px"> <h3>Type Theory</h3> To understand the lynx type system we first need some background in traditional type theory. Unlike types for languages like C++ or Java, types in lynx have a more formal structure. This chapter will be written without the expectation that you have any background in formal type theories and should be accessible to someone familiar with programming in dynamically typed languages like python or javascript. If you already know type theory you can skip this section and the section on Algebraic Data Types. <p> We will use construction of a coordinate point as a motivating example throughout this chapter. A coordinate point consists of an x-coordinate and a y coordinate and can be written as a pair (x,y). Notice that this contains two pieces of information: an x-coordinate that is a number and a y-coordinate that is a number. We will use the notation \(x: \text{Number}\) (read "\(x\) is of type number") as a shorthand. With this notation we can also say, \(y: \text{Number}\) and \((x, y):\text{CoordinatePoint}\). </p> <p> Formal type theory has different kinds of rules that describe how types are formed and used. We will introduce 3 types of rules: introduction rules, elimination rules and computation rules. <ol> <li>The Introduction rule describes how a type is constructed</li> <li>The Elimination rule describes how a type that is already constructed can be broken back apart into its pieces</li> <li>The Computation rule checks that the introduction rules match with the elimination rules and creates a way to "run" these types as programs</li> </ol> </p> <h4>Introduction Rules</h4> <p> Given we have something called x that is a number and we have something called y that is a number we can create a coordinate point \((x, y)\). The notation we use for this in type theory is: \[\frac{x:\text{Number} \quad y:\text{Number}}{(x, y):\text{CoordinatePoint}}\] The text above the line are the assumptions required for the text below the line to be true. So to create a coordinate point we need a number \(x\) and a number \(y\). Assuming we have both of these we can create a coordinate point. </p> <h4>Elimination Rules</h4> <p> Elimination rules are sort of the inverse of introduction rules. They ask "given that we already have a coordinate point, what information can we pull out of it?" In this case there two elimination rules that we'll call \(E_1\) and \(E_2\):\[\begin{align} \frac{(x, y):\text{CoordinatePoint}}{x:\text{Number}}(E_1) && \frac{(x, y):\text{CoordinatePoint}}{ y:\text{Number}}\left(E_2\right)\end{align}\] \(E_1\) says that we if we have a coordinate point we can extract an x coordinate that is of type number and \(E_2\) says that we can also extract a y-coordinate of type number. Notice that these elimination rules are a sort of inverse to the introduction rule. The introduction rule shows how to put pieces together and the elimination rule shows how to take them back apart. This concept will be made more formal with the computation rule.If all of this seems too basic to you, consider this: Even though these rules are simple and may seem trivial, they form a structure of types that can be checked by a computer. As types get more complicated, the computer can check that the programmer has handled every case and that the types fit together. The mechanization this allows is the important part </p> <h4>Computation Rules</h4> </div> <div> <h2>Concrete Types</h2> <h3>Type Equality</h3> <h3>Canonicity</h3> <h3>Inheritance</h3> <h4>Subsumption Principle</h4> </div> <div> <h2 id="type-equality">Equality Relations</h2> <p> Lynx has a richer notion of equality of elements than other languages. It is built on top of lynx expressions in the form of equality relations. </p> Atomic Equality \[\frac{v:\tau}{v=_\tau v}\] Expression Equality \[\frac{e_1\Downarrow_\tau v_1 \quad e_2\Downarrow_\tau v_2 \quad v_1\equiv_\tau v_2}{e_1 =_\tau e_2} \] Product Type Equality \[\frac{e_1 =_\tau e_2 \quad e_3 =_\sigma e_4}{e_1 \times e_3 =_{\tau \times \sigma} e_2 \times e_4}\] Sum Type Equality \[\frac{}{}\] Use two representations of the natural numbers as an example. We want to be able to prove that the binary representation of the natural numbers is equal to the unary representation Function Equality One approach to determining equality of functions is called Function Extensionality. Under this definition, two functions \(f: A\rightarrow B\) and \(g: A \rightarrow B\) are equivalent iff for every \(a:A\) \(f(a) =_B g(a)\) Reflexivity \[\frac{e:\tau}{e =_\tau e}\] </div> <h1 id="implementation">Part III &#8211; Implementation</h1> <div> <p> One of the goals of lynx is to separate the specification of a program from its implementation. The specification and implementation of the language itself is no different. Lynx is (eventually) written in itself so the underlying implementation of the language can be swapped out without affecting its behavior. </p> <h2>Primitives</h2> <p> The most basic way the implementation and the specification are separated is with the concept of primitives. A specification for a basic building block of computation serves as the denotational semantics for an underlying language feature that does the actual computation. For example, we could define a type in lynx for 32 bit unsigned integers as a list of binary digits with length 32. We can then define a webAssembly uint32 as a primitive for this type. The primitive states without proof (but with tests) that the specification for a uint32 has a one-to-one correspondence with a webassembly uint32. The compiler can then decide to use the webassembly uint32 as an optimization. In practice, this is how all computation in lynx is done. </p> </div> <div> <h3 id="persistence">Persistence</h3> <p> Each object in lynx is identified with a hash. Informally, the hash of an object is calculated by recursively hashing all of the child nodes of the current object. Let \(H: \text{LynxObject} \rightarrow \{0,1\}^n\) be a cryptographic hash function The hash of a node is just the result of hashing its children together to form an unbalanced Merkle tree. Starting at the bottom of the tree we apply a the hash function \(H\) to the values 20, 30 and "text" respectively. Prepend leaf nodes with a 0x00 byte and internal nodes with a 0x01 byte to prevent a second preimage attack. </p> </div> </div> <div id="notes"> <aside class="notes" style="display:block;">Informal notes or commentary will be on the right. Click on highlighted parts of the text for help with notation</aside> </div> </div> </body></html>