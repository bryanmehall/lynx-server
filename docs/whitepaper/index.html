<!DOCTYPE html><html><head><title>Whitepaper &ndash; Lynx</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="stylesheet" href="/styles.5f5ba09c.css"><link rel="icon shortcut" type="image/png" href="/favicon.f1cf22ff.png"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={chtml:{scale:.8},svg:{scale:.8}};</script></head><body> <div id="header"> <a href="/"> <div id="logo" class="header-tab"> <img src="/lynx_logo.04401f14.svg" alt="home" height="80" width="80"> <div style="padding-top:38px;font-weight:500;font-size:30pt;align-items:baseline;">Lynx</div> </div> </a> <a class="header-tab" href="/demos/">Demos</a> <a class="header-tab" href="/sandbox/">Sandbox</a> <a class="header-tab" href="/development/">Development</a> <a class="header-tab" href="/whitepaper/">Whitepaper</a> </div> <div class="content"> This is a working draft of the design rationale and formal specification of the Lynx Programming Language </div> <div class="whitepaper"> <div class="outline"> <ul> <li>Part I &#8211; Design</li> <ul> <li><a href="#what-is-programming">What is Programming?</a></li> <li>Programming Interface</li> <ul> <li>Human Representations</li> <li>Why Not Code?</li> <li>Machine Representations</li> </ul> <li>Programming Ecosystem</li> <ul> <li>The Mess We're In</li> </ul> <li>Software Correctness</li> </ul> <li>Part II &#8211; Specification</li> <ul> <li><a href="#object-context">The Object-Context Paradigm</a></li> <li>Correspondence with Functional Programming</li> <li><a href="#statics">Statics</a></li> <ul> <li>Abstract Syntax</li> <li>Typing Judgements</li> </ul> <li>Dynamics</li> <li><a href="#types">Types</a></li> <ul> <li>Equality</li> <li>Subtyping</li> <li>Canonicity</li> <li>Approximations</li> </ul> <li>State</li> <li>Events</li> </ul> <li>Part III &#8211; Implementation</li> <ul> <li>Metacircularity</li> <li>Primitives</li> <li>Modules</li> <li>Optimization</li> <li>Approximation</li> </ul> </ul> </div> <div class="formal whitepaperContent"> <h1>Part I &#8211; Design</h1> <p> Lynx is a computable specification language designed to make building great software more intuitive and efficient. Programming is fundamentally about human communication. After a brief discussion about the philosophy behind Lynx and what a programming ecosystem should look like, this document will detail the formal specification of the Lynx language. </p> <div> <h2 id="#what-is-programming">What is Programming?</h2> <p> When most people think about programming they think about writing code. Instead, it should be thought of in a more abstract way as the act of communicating complex ideas precisely. With traditional programming languages, programmers are really doing two separate acts at the same time: Writing code to communicate with computers and writing documentation to communicate with other programmers. These two parts are held together with an informal set of best practices that are but they should be unified within a programming environment. </p> <img src="/design-spec-implementation.fdf42a50.svg" alt="programming workflow" class="diagram" style="width:521px"> </div> <h2>Why not code? </h2> Traditional text-based coding is the standard that almost every general purpose programming language uses because of its expressive power and flexibility. The few graphical programming languages that exist fall short because they try to replicate the semantics of text-based code but in graphical form. Lynx takes a different approach. <h3> The Mess We're In</h3> <p> The Lynx language is an attempt to rebuild the programing ecosystem from first principles. Joe Armstrong, the inventor of Erlang </p> <h1>Part II &#8211; Specification</h1> <div> <h2 id="object-context">The Object-Context Paradigm</h2> <p> With lynx we introduce a new programming paradigm called the object-context paradigm. The object oriented style matches the way people think about concepts in the real world more closely than functional or imperative programming styles. This is one reason for the relative popularity of object oriented programming. Lynx uses a carefully constrained form of Object Oriented programming such that the richer analysis tools from functional programming can be used. Lynx is a purely declarative form of object oriented programming. </p> <p> Objects in Lynx consist of a mapping between attributes and values. Both attributes and values are also objects. One way to represent objects graphically is with a tree diagram where the objects are nodes and the attributes are edges. </p> <img src="/object-value.fc10c100.svg" alt="Object and value connected by attribute" class="diagram" style="width:43px"> <p> Objects can have multiple attributes that are represented as different branches of the tree. and because values are also objects the tree can be multiple levels deep. This forms a recursive data type that can be used to represent any other data type in lynx. </p> <img src="/multiple-attributes.170afbb6.svg" alt="Objects can have multiple attributes" class="diagram" style="width:181px"> <p> We will use text being drawn on a screen as an example. The text can have several attributes like its position on the screen, the string to be printed, font type, font size etc. We can also attach metadata like the name of the textbox as an attribute. </p> <img src="/simple-text-box.b497ecf9.svg" alt="simple text box" class="diagram" style="width:341px"> <p> Every tree or subtree in this diagram is an object. So far, this is just describes a static graphical layout. Lynx is able to do computation when we introduce context and references. </p> <p> We can describe a text object (text box) whose position is defined by the graphical element it is put inside. We will call the "parentElement" of the text box "group" and then we will put the group element inside of a window. </p> <img src="/text-box.e93ad776.svg" alt="Objects can have multiple attributes" class="diagram" style="width:411px"> <p> This can be represented by the lynx object tree: </p> <img src="/text-box-tree.033bbf42.svg" alt="Objects can have multiple attributes" class="diagram" style="width:645px"> <p> In this case the text object (text and everything below it) is placed in the context of the group. The text object has two references that refer to values outside of the text object. The reference "group.position.x" refers to the the x component of the position of the group object. The text object will always behave the same way if it is placed in an identical "group" context. We can think of an object as a pure function and the references to the context it is in corresponds to the arguments of that pure function. So now if we change the position of the "group" element then the text will follow and always be offset by \((20, 20)\) </p> <img src="/text-box-moved.b1527f1d.svg" alt="text box moved in group" class="diagram" style="width:253px"> <p> We've now made these definitions dynamic but with this system "text" is not really isolated from "group" because the references still refer to "group" by name. It would be nicer if we could say that the position of "text" is relative to whatever it's parent element is. To solve this problem we can define a concept called an inverse attribute. In this case "parentElement" is the inverse attribute of "childElement" </p> <img src="/inverse-attributes.637dda3b.svg" alt="parentElement is inverse to childElement" class="diagram" style="width:566px"> <p> With inverse attributes, the definition of "text" depends on the context it is in. Its parentElement can have any name but it must have a position with x and y attributes. We can again think of text as a pure function with these references as arguments. </p> <p> This forms the core part of the lynx language. Next, we will look at how these object graphs can change over time in response to new data and store state. </p> <h3>Events and State</h3> <p> So far, we have discussed how static lynx objects are structured and evaluated. They can also change in response to outside events and store data. We'll start with a simple, non-stateful example where the position of the text box is set to be the position of the user's mouse. </p> </div> <div> <h2>Formal Specification</h2> Lynx should be thought of more as a specification language than a programming language because it is designed with an extra layer of abstraction that makes it possible to manipulate meta-data about programs. <ol> <li> <b>Lynx Expressions:</b> a kind of way of storing meta-data and relations between objects. In the type system, everything is a subtype of Lynx expression </li> <li> <b>Abstract Types:</b> types like product types, sum types and function types are defined in terms of lynx expressions and are therefore a subtype of lynx expressions. </li> <li> <b>Concrete Types:</b> numbers, strings lists, trees, etc. are subtypes of abstract types </li> <li> <b>Instances:</b> 1,2,3, "abc" are all subtypes of their corresponding types. </li> </ol> This will be discussed in more detail, but note that in lynx there is no distinction between types and instances. The number 3 can just be considered a subtype of the concept number. <p> The lynx language is formally defined in two steps: <ol> <li><b>statics: </b>specification of what makes a program well-formed</li> <li><b>dynamics: </b>specification for evaluating a well-formed program</li> </ol> Unlike most languages, Lynx does not have separate phases for write-time, type checking, compile-time- and run-time. Therefore the dynamics are defined in such a way that at every step of evaluation the resulting program is also correct as defined by the statics. More formally, given a well-formed Lynx expression \(E\) and an evaluation event \(\mapsto\) the dynamics ensures that that the resulting Lynx expression \(E'\) is also well-formed for the evaluation expression \(E \mapsto E'\) </p> <h2 id="statics">Statics</h2> <h3 id="abstract-syntax">Abstract Syntax</h3> <h4 id="lynx-expression">Lynx Expressions</h4> \[LynxExpression ::= \left\{ a \: |\: a:( \href{#lynx-attribute}{Attribute}, LynxExpression) \right\}\] <a href="#lynx-expression" class="def">Lynx expressions</a> consist of a set of mappings between an <a href="#lynx-attribute" class="def">attribute</a> and another Lynx expression. The definition is intentionally broad because they are designed to encapsulate the properties, metadata, and relations of any concept. They are the only first-class concepts in the lynx language. Note that Lynx expressions don't inherently contain any information. Their meaning is only derived by their relation to other lynx expressions. To highlight why this design decision is important we can use the concept of a function as an example. Something like a function that would normally be a first class object in a programming language is not in lynx because it would be missing important meta-data. Lynx expressions can capture the essential information about functions by defining an "argument" and a "result" attribute that can be used by the evaluator. The name of the function other meta-data can also be added as an attribute. The inverse of the function can be added as a relation. The structure of Lynx Expressions form a graph where the expressions are nodes and the attributes are edges. <h4 id="lynx-attribute">Attributes</h4> \[Attribute ::= \left\{ a \: |\: a:(Attribute, \href{#lynx-expression}{LynxExpression}) \right\}, \href{#lynx-property}{Property} \:|\: \href{#relation}{Relation}\] Attributes are a subtype of lynx expressions. <h4 id="atom">Atoms</h4> \[Atom ::= \] <h4 id="lynx-object">Lynx Objects</h4> \[LynxObject ::= \left\{ a \: |\: a:(Property, LynxObject \: | \: Atom) \right\}\] Lynx objects are an inductively defined tree structure consisting of a mapping between a finite set of <a href="#lynx-property" class="def">Properties</a> and corresponding <a href="#lynx-object" class="def">Lynx Objects</a>. Lynx objects are useful for the serialization, analysis and storage of <a href="#lynx-expression" class="def">Lynx Expressions</a>. Should the name of lynx expressions and lynx objects be switched? Lynx objects can always be serialized and content addressed because they are non-cyclic by definition. This is covered in more detail in the Object Persistance specification. Lynx expressions can be simplified to Lynx objects with respect to certain properties. <h4 id="lynx-property">Properties</h4> \[Property ::= \href{#lynx-object}{LynxObject}\] A lynx property is a non-cyclic version of an attribute. It can not have relations to other properties or attributes. <h4 id="relation">Relations</h4> \[Relation ::= \href{#lynx-expression}{Lynx Expression}\] <h4 id="reference">References</h4> \[Reference ::= \] <h4 id="local-reference">Local References</h4> \[LocalReference ::= \] <h4 id="global-reference">Global References</h4> \[GlobalReference ::= \] <h3>Typing Judgements</h3> </div> <div> <h2 id="types">Types</h2> <p> Types are used to constrain the behavior of programs and, when they are well-formed, ensure correctness within the boundaries of the type system. In some dynamically types languages like javascript or python every the typing is considered "weak" because there are very few rules about which objects can be used in which places. This is often seen as a feature because it is less confusing for beginners writing simple programs. </p> <p> Lynx takes the opposite approach. Type structures can always be relaxed selectively but when there is no type structure then the ability to reason about programs is lost. One way of thinking about it is that a weakly typed language can be created in a strongly typed language by purposefully relaxing all of the rules but the rules but a strongly typed language can not be replicated in a weakly typed language so the strongly typed language must be more expressive. </p> <p> <ul> <li>Problem #1: Types specify structure not behavior</li> <li>Problem #2: Equal types are not necessarily interchangeable</li> <li>Problem #3: Data can only be an instance of a single type</li> </ul> </p> <h3 id="types-through-examples">Types Through Examples</h3> <p> When we are programming is is useful to start defining types as the simple case and then creating a more general version later. This process of generalizations often gets programmers in trouble where they used a specific version of a type somewhere in their code and the new generalization breaks it. let's start with a very basic example. We can create a new object called "zero" and say it is an element of the natural numbers by adding a subtype (isA) relation between it and the "natural number" object. </p> <img src="/zero-nat.490f17c2.svg" alt="Zero is a Natural Number" class="diagram" style="width:191px"> <p> Now we can say "one is also a natural number" so we add the definition \(\text{One}: \text{Nat}\) and \(\text{Two}:\text{Nat}\) </p> <img src="/n-nat.a1d83c7d.svg" alt="Zero is a Natural Number" class="diagram" style="width:221px"> <h3>Type Theory</h3> To understand the lynx type system we first need some background in traditional type theory. Unlike types for languages like C++ or Java, types in lynx have a more formal structure. This chapter will be written without the expectation that you have any background in formal type theories and should be accessible to someone familiar with programming in dynamically typed languages like python or javascript. If you already know type theory you can skip this section and the section on Algebraic Data Types. <p> We will use construction of a coordinate point as a motivating example throughout this chapter. A coordinate point consists of an x-coordinate and a y coordinate and can be written as a pair (x,y). Notice that this contains two pieces of information: an x-coordinate that is a number and a y-coordinate that is a number. We will use the notation \(x: \text{Number}\) (read "\(x\) is of type number") as a shorthand. With this notation we can also say, \(y: \text{Number}\) and \((x, y):\text{CoordinatePoint}\). </p> <p> Formal type theory has different kinds of rules that describe how types are formed and used. We will introduce 3 types of rules: introduction rules, elimination rules and computation rules. <ol> <li>The Introduction rule describes how a type is constructed</li> <li>The Elimination rule describes how a type that is already constructed can be broken back apart into its pieces</li> <li>The Computation rule checks that the introduction rules match with the elimination rules and creates a way to "run" these types as programs</li> </ol> </p> <h4>Introduction Rules</h4> <p> Given we have something called x that is a number and we have something called y that is a number we can create a coordinate point (x, y). The notation we use for this in type theory is: \[\frac{x:\text{Number} \quad y:\text{Number}}{(x, y):\text{CoordinatePoint}}\] The text above the line are the assumptions required for the text below the line to be true. So to create a coordinate point we need a number \(x\) and a number \(y\). Assuming we have both of these we can create a coordinate point. </p> <h4>Elimination Rules</h4> <p> Elimination rules are sort of the inverse of introduction rules. They ask "given that we already have a coordinate point, what information can we pull out of it?" In this case there two elimination rules that we'll call \(E_1\) and \(E_2\):\[\begin{align} \frac{(x, y):\text{CoordinatePoint}}{x:\text{Number}}(E_1) && \frac{(x, y):\text{CoordinatePoint}}{ y:\text{Number}}\left(E_2\right)\end{align}\] \(E_1\) says that we if we have a coordinate point we can extract an x coordinate that is of type number and \(E_2\) says that we can also extract a y-coordinate of type number. Notice that these elimination rules are a sort of inverse to the introduction rule. The introduction rule shows how to put pieces together and the elimination rule shows how to take them back apart. This concept will be made more formal with the computation rule.If all of this seems too basic to you, consider this: Even though these rules are simple and may seem trivial, they form a structure of types that can be checked by a computer. As types get more complicated, the computer can check that the programmer has handled every case and that the types fit together. The mechanization this allows is the important part </p> <h4>Computation Rules</h4> </div> <h1>Part III &#8211; Implementation</h1> <div> <p> One of the goals of lynx is to separate the specification of a program from its implementation. The specification and implementation of the language itself is no different. Lynx is (eventually) written in itself so the underlying implementation of the language can be swapped out without affecting its behavior. </p> <h2>Primitives</h2> <p> The most basic way the implementation and the specification are separated is with the concept of primitives. A specification for a basic building block of computation serves as the denotational semantics for an underlying language feature that does the actual computation. For example, we could define a type in lynx for 32 bit unsigned integers as a list of binary digits with length 32. We can then define a webAssembly uint32 as a primitive for this type. The primitive states without proof (but with tests) that the specification for a uint32 has a one-to-one correspondence with a webassembly uint32. The compiler can then decide to use the webassembly uint32 as an optimization. In practice, this is how all computation in lynx is done. </p> </div> </div> <div class="notes">Informal notes or commentary will be on the right. Click on highlighted parts of the text for help with notation</div> </div> </body></html>