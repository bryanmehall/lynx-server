<div>
    <h2>Formal Specification</h2>
    Lynx should be thought of more as a specification language than a programming language because it is designed with an extra layer of abstraction that makes it possible to manipulate meta-data about programs.
    <ol>
        <li>
            <b>Lynx Expressions:</b> a kind of way of storing meta-data and relations between objects. In the type system, everything is a subtype of Lynx expression
        </li>
        <li>
            <b>Abstract Types:</b> types like product types, sum types and function types are defined in terms of lynx expressions and are therefore a subtype of lynx expressions.
        </li>
        <li>
            <b>Concrete Types:</b> numbers, strings lists, trees, etc. are subtypes of abstract types
        </li>
        <li>
            <b>Instances:</b> 1,2,3, "abc" are all subtypes of their corresponding types. 
        </li>
    </ol>
    This will be discussed in more detail, but note that in lynx there is no distinction between types and instances. The number 3 can just be considered a subtype of the concept number. 
    <p>
        The lynx language is formally defined in two steps:
        <ol>
            <li><b>statics: </b>specification of what makes a program well-formed</li>
            <li><b>dynamics: </b>specification for evaluating a well-formed program</li>
        </ol>
        Unlike most languages, Lynx does not have separate phases for write-time, type checking, compile-time- and run-time. 
        Therefore the dynamics are defined in such a way that at every step of evaluation the resulting program is also correct as defined by the statics. More formally, given a well-formed Lynx expression \(E\) and an evaluation event \(\mapsto\) the dynamics ensures that that the resulting Lynx expression \(E'\) is also well-formed for the evaluation expression \(E \mapsto E'\)
    </p>
    <h2 id="statics">Statics</h2>

    <h3 id="abstract-syntax">Abstract Syntax</h3>

    <h4 id="lynx-expression">Lynx Expressions</h4>
    \[LynxExpression ::= \left\{ a \: |\: a:( \href{#lynx-attribute}{Attribute}, LynxExpression) \right\}\]
    <a href="#lynx-expression" class="def">Lynx expressions</a> consist of a set of mappings between an <a href="#lynx-attribute" class="def">attribute</a> and another Lynx expression. The definition is intentionally broad because they are designed to encapsulate the properties, metadata, and relations of any concept. They are the only first-class concepts in the lynx language. Note that Lynx expressions don't inherently contain any information. Their meaning is only derived by their relation to other lynx expressions. To highlight why this design decision is important we can use the concept of a function as an example. Something like a function that would normally be a first class object in a programming language is not in lynx because it would be missing important meta-data. Lynx expressions can capture the essential information about functions by defining an "argument" and a "result" attribute that can be used by the evaluator. The name of the function other meta-data can also be added as an attribute. The inverse of the function can be added as a relation. The structure of Lynx Expressions form a graph where the expressions are nodes and the attributes are edges.
    <h4 id="lynx-attribute">Attributes</h4>
    \[Attribute ::= \left\{ a \: |\: a:(Attribute, \href{#lynx-expression}{LynxExpression}) \right\}, \href{#lynx-property}{Property} \:|\: \href{#relation}{Relation}\]
    Attributes are a subtype of lynx expressions. <!--TODO: attributes can be composed (function composition) and extra information can be added (currying)-->
    <h4 id="atom">Atoms</h4>
    \[Atom ::= \]
    
    <h4 id="lynx-object">Lynx Objects</h4>
    \[LynxObject ::= \left\{ a \: |\: a:(Property, LynxObject \: | \: Atom) \right\}\]
    Lynx objects are an inductively defined tree structure consisting of a mapping between a finite set of  <a href="#lynx-property" class="def">Properties</a> and corresponding <a href="#lynx-object" class="def">Lynx Objects</a>.
    Lynx objects are useful for the serialization, analysis and storage of <a href="#lynx-expression" class="def">Lynx Expressions</a>. Should the name of lynx expressions and lynx objects be switched? Lynx objects can always be serialized and content addressed because they are non-cyclic by definition. This is covered in more detail in the Object Persistance specification. Lynx expressions can be simplified to Lynx objects with respect to certain properties. 
    <h4 id="lynx-property">Properties</h4>
    \[Property ::= \href{#lynx-object}{LynxObject}\]
    A lynx property is a non-cyclic version of an attribute. It can not have relations to other properties or attributes.
    <h4 id="relation">Relations</h4>
    \[Relation ::= \href{#lynx-expression}{Lynx Expression}\]
    <h4 id="reference">References</h4>
    \[Reference ::= \]
    <h4 id="local-reference">Local References</h4>
    \[LocalReference ::= \]
    <h4 id="global-reference">Global References</h4>
    \[GlobalReference ::= \]
    
    <h3>Typing Judgements</h3>

</div>